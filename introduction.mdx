# Harshith Mullapudi

## About

Hi, I'm Harshith Mullapudi. I'm an engineer by profession, based in India. When I'm not developing or mapping out workflows, I spend my time reading, hiking, or exploring local cricket leagues—the mix of the outdoors and competitive sports is my clear preference. I'm keenly interested in system architecture and automation, and in my downtime, I challenge myself with strategy board games and occasional tinkering with digital art tools.

## Work

I am currently the principal engineer and core architect at RedPlanetHQ, where I lead the development and technical strategy of our primary system, the `core` repository. My focus areas include designing robust memory architectures, standardizing integration points across products such as SOL and CORE, and ensuring strict traceability in all product workflows. My day-to-day involves a high degree of action-oriented decision-making, task management via GitHub issues and Linear, and continuous improvement of automation and system consistency.

Prior to my current role, I was a senior developer at RedPlanetHQ. This period was dedicated to building foundational systems for SOL—the product interface layer—where I implemented workflow automation pipelines and designed integration mechanisms leveraging the Multi-Channel Provider (MCP) architecture. My responsibilities covered development, refactoring, and modularization of integration code, always referencing canonical repositories (branch naming patterns consistently using `harshith/…`). Before joining RedPlanetHQ, I held an engineering internship at an enterprise SaaS provider, focusing on early-stage memory graph implementations and operationalizing context transfer protocols between disparate microservices, which required in-depth knowledge of service boundaries and strict audit logging.

My areas of interest span memory architectures, system integration, task automation, and end-to-end workflow reliability. I have deep technical expertise in orchestrating cross-system context management, architectural separation of concerns, and implementing traceable, auditable pipelines. I work extensively with GitHub for version control and canonical source tracking, leveraging Linear, Figma, and sol-cli for workflow orchestration and design automation. Over the last four years, I have designed and refactored memory architectures, implemented context syncing across SOL, MCP, and third-party authentication providers, and resolved complex integration challenges for core products.

Technologies I've worked with include TypeScript, Next.js, Node.js, and a wide range of automation and DevOps tools. My systems work regularly addresses persistent storage, semantic clustering for memory optimization, detailed error logging, and the construction of reliable episodes for analytics. Issues and implementations are always linked back to specific repositories and branches—for example, most recent tasks are tracked in `redplanethq/core` and referenced as `harshith/{feature}` branches for actionable auditability.

I actively contribute to and maintain several open-source projects, particularly those I use in day-to-day workflow optimization—including core task runners, context migration utilities, and integration adaptors. My main public repositories are available on GitHub, such as `redplanethq/core`, and I follow a disciplined process of logging every major contribution, task creation, and status change, enabling transparent collaboration.

## Setup

My development environment is tightly integrated around modularity and automation. I primarily use Cursor and Claude Code as my editors of choice, with Terminal workflows heavily automated using sol-cli—every routine operation or integration is documented, scripted, and version-controlled. Source control is managed with GitHub, where branches and issues are explicitly named and linked to match the task-action format. For task and project management, Linear is used externally and SOL provides an interface for deep workflow tracking. Documentation and notes are consistently centralized in Notion and Obsidian, with context always surfaced and kept in sync. The setup is tuned for reliability, context accessibility, and rapid, action-oriented iteration.